import React, { useState } from 'react';
import { useSelector } from 'react-redux';
import { useNavigate, useParams } from 'react-router-dom';
import { setCurrentReport } from '../store/slices/reportSlice';
import { generateReport } from '../store/reportSlice';
import { RootState } from '../store';
import { HostInfo, PortInfo, Vulnerability } from '../types';
import { useAppDispatch } from '../store/hooks';
import { Card, CardHeader, CardTitle, CardContent, CardFooter } from '../components/ui/card';
import { Button } from '../components/ui/button';
import { Badge } from '../components/ui/badge';
import { Alert, AlertTitle, AlertDescription } from '../components/ui/alert';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "../components/ui/accordion";
import { ChevronDown } from 'lucide-react';

const VulnerabilityResults: React.FC = () => {
  const dispatch = useAppDispatch();
  const navigate = useNavigate();
  const { scanId } = useParams<{ scanId: string }>();
  const { currentVulnerability, loading } = useSelector((state: RootState) => state.vulnerability);
  const [isGeneratingReport, setIsGeneratingReport] = useState(false);
  const [reportError, setReportError] = useState<string | null>(null);
  
  if (!currentVulnerability) {
    return (
      <Card className="mt-8">
        <CardHeader>
          <CardTitle>취약점 분석 결과</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="p-4 border rounded bg-secondary text-secondary-foreground">
            취약점 데이터를 로드하는 중이거나 사용 가능한 결과가 없습니다.
          </div>
        </CardContent>
      </Card>
    );
  }
  
  // 리포트 생성 함수
  const handleGenerateReport = async () => {
    if (!scanId) {
      setReportError('스캔 ID가 없습니다.');
      return;
    }
    
    setIsGeneratingReport(true);
    setReportError(null);
    
    try {
      console.log('리포트 생성 요청 시작...', { scanId });
      
      // Redux 액션을 사용하여 리포트 생성
      const result = await dispatch(generateReport(scanId)).unwrap();
      
      console.log('리포트 생성 완료:', result);
      
      // 리포트 상세 페이지로 이동
      if (result && result.report_id) {
        // 세션 스토리지에 임시로 리포트 데이터 저장 (중복 보험)
        sessionStorage.setItem('current_report', JSON.stringify(result));
        navigate(`/reports/${result.report_id}`);
      } else {
        console.error('리포트 ID를 받지 못했습니다:', result);
        setReportError('리포트 ID를 받지 못했습니다. 서버 응답에 report_id가 없습니다.');
      }
    } catch (error: any) {
      console.error('리포트 생성 실패:', error);
      setReportError(error?.message || '리포트 생성 중 오류가 발생했습니다.');
    } finally {
      setIsGeneratingReport(false);
    }
  };
  
  // 취약점이 있는 호스트/포트의 수 계산
  const vulnerableHosts = currentVulnerability.hosts.filter((host: HostInfo) => 
    host.ports.some((port: PortInfo) => port.vulnerabilities && port.vulnerabilities.length > 0)
  );
  
  const totalVulnerabilities = currentVulnerability.hosts.reduce((total: number, host: HostInfo) => {
    return total + host.ports.reduce((portTotal: number, port: PortInfo) => {
      return portTotal + (port.vulnerabilities?.length || 0);
    }, 0);
  }, 0);
  
  // CVSS 점수에 따른 색상 클래스 결정
  const getCvssSeverity = (score: number) => {
    if (score >= 9) return 'destructive';
    if (score >= 7) return 'destructive';
    if (score >= 4) return 'warning';
    return 'success';
  };
  
  // 서비스 타입에 따라 아이콘 반환
  const getServiceIcon = (service?: string) => {
    if (!service) return '🔌';
    
    switch (service.toLowerCase()) {
      case 'http': case 'https': return '🌐';
      case 'ssh': return '🔒';
      case 'ftp': return '📁';
      case 'smtp': case 'pop3': case 'imap': return '✉️';
      case 'dns': return '🔍';
      case 'mysql': case 'postgresql': case 'oracle': case 'mssql': return '🗄️';
      case 'telnet': return '📺';
      case 'rdp': return '🖥️';
      default: return '🔌';
    }
  };
  
  // 스크립트 ID에 따라 사용자 친화적 제목 반환
  const getScriptTitle = (id?: string) => {
    if (!id) return '정보';
    
    switch (id) {
      case 'http-title': return '페이지 제목';
      case 'http-robots.txt': return '로봇 배제 표준';
      case 'http-server-header': return '웹 서버 정보';
      case 'http-methods': return '지원 HTTP 메소드';
      case 'ssl-cert': return 'SSL 인증서';
      case 'ssh-hostkey': return 'SSH 호스트 키';
      case 'banner': return '서비스 배너';
      default: return id;
    }
  };
  
  // 스크립트 타입에 따라 배경색 지정
  const getScriptBackground = (id?: string) => {
    if (!id) return '';
    
    if (id.startsWith('http-')) return 'bg-blue-50/30';
    if (id.startsWith('ssl-')) return 'bg-green-50/30';
    if (id.startsWith('ssh-')) return 'bg-yellow-50/30';
    if (id.startsWith('ftp-')) return 'bg-purple-50/30';
    return '';
  };
  
  // 취약점의 심각도에 따른 배지 색상
  const getSeverityColor = (score: number) => {
    if (score >= 9) return 'bg-red-500 text-white';
    if (score >= 7) return 'bg-orange-500 text-white';
    if (score >= 4) return 'bg-yellow-500 text-black';
    return 'bg-green-500 text-white';
  };
  
  return (
    <Card className="mt-8">
      <CardHeader>
        <CardTitle>취약점 분석 결과</CardTitle>
      </CardHeader>
      
      <CardContent>
        {reportError && (
          <Alert variant="destructive" className="mb-4">
            <AlertTitle>리포트 생성 오류</AlertTitle>
            <AlertDescription>{reportError}</AlertDescription>
          </Alert>
        )}
        
        <div className="mb-6 grid grid-cols-2 gap-4">
          <div className="p-4 bg-secondary/50 rounded">
            <div className="text-2xl font-bold">{vulnerableHosts.length}</div>
            <div className="text-sm text-muted-foreground">취약한 호스트</div>
          </div>
          <div className="p-4 bg-secondary/50 rounded">
            <div className="text-2xl font-bold">{totalVulnerabilities}</div>
            <div className="text-sm text-muted-foreground">발견된 취약점</div>
          </div>
        </div>
        
        {currentVulnerability.hosts.map((host: HostInfo, index: number) => {
          // 취약점이 있는 포트만 필터링
          const vulnerablePorts = host.ports.filter((port: PortInfo) => 
            port.vulnerabilities && port.vulnerabilities.length > 0
          );
          
          if (vulnerablePorts.length === 0) return null;
          
          return (
            <div key={index} className="mb-6 border-b pb-4">
              <h3 className="text-lg font-medium">{host.host}</h3>
              
              {vulnerablePorts.map((port: PortInfo, portIndex: number) => (
                <div key={portIndex} className="mb-5">
                  <h4 className="text-md font-medium mt-3 mb-2">
                    {port.port}/{port.service} - {port.product} {port.version}
                  </h4>
                  
                  {/* 서비스 스크립트 정보 섹션 추가 */}
                  {port.scripts && port.scripts.length > 0 && (
                    <div className="mb-4 bg-muted/20 p-3 rounded">
                      <div className="text-sm font-medium mb-2">{getServiceIcon(port.service)} 서비스 정보</div>
                      <div className="grid grid-cols-1 gap-2">
                        {port.scripts.map((script: any, scriptIndex: number) => (
                          <div key={scriptIndex} className={`text-sm p-2 rounded border ${getScriptBackground(script.id)}`}>
                            <div className="font-medium text-xs mb-1">{getScriptTitle(script.id)}</div>
                            <div className="whitespace-pre-wrap text-muted-foreground text-xs max-h-[150px] overflow-y-auto scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-100">{script.output}</div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* 취약점 정보를 아코디언(드롭다운) 형식으로 표시 */}
                  {port.vulnerabilities && port.vulnerabilities.length > 0 && (
                    <div className="mb-3">
                      <h5 className="text-sm font-medium mb-2">발견된 취약점 ({port.vulnerabilities.length}개)</h5>
                      <div className="max-h-[400px] overflow-y-auto scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-100 pr-1 border rounded-md">
                        <Accordion type="single" collapsible className="w-full">
                          {port.vulnerabilities.map((vuln: Vulnerability, vulnIndex: number) => (
                            <AccordionItem key={vulnIndex} value={`vuln-${portIndex}-${vulnIndex}`} className="border-b last:border-b-0 overflow-hidden">
                              <AccordionTrigger className="px-3 py-2 hover:no-underline hover:bg-muted/30">
                                <div className="flex items-center justify-between w-full">
                                  <div className="font-medium text-sm whitespace-nowrap mr-2">{vuln.cve_id}</div>
                                  <div className="text-xs text-blue-500 underline px-2 flex-1">
                                    <a href={`https://vulners.com/cve/${vuln.cve_id}`} target="_blank" rel="noopener noreferrer" onClick={(e) => e.stopPropagation()}>
                                      https://vulners.com/cve/{vuln.cve_id}
                                    </a>
                                  </div>
                                  <Badge variant={getCvssSeverity(vuln.cvss_score)} className="ml-2">
                                    CVSS: {vuln.cvss_score.toFixed(1)}
                                  </Badge>
                                </div>
                              </AccordionTrigger>
                              <AccordionContent className="px-3 py-2 bg-muted/10">
                                <div className="font-medium text-sm mb-1">{vuln.title}</div>
                                <div className="text-xs text-muted-foreground max-h-[200px] overflow-y-auto scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-100">{vuln.description}</div>
                              </AccordionContent>
                            </AccordionItem>
                          ))}
                        </Accordion>
                      </div>
                    </div>
                  )}
                </div>
              ))}
            </div>
          );
        })}
      </CardContent>
      
      <CardFooter>
        <Button 
          className="w-full" 
          onClick={handleGenerateReport} 
          disabled={loading || isGeneratingReport}
        >
          {isGeneratingReport ? '리포트 생성 중...' : '리포트 생성'}
        </Button>
      </CardFooter>
    </Card>
  );
};

export default VulnerabilityResults; 